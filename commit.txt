This file will be deleted.

What do you plan to incldue in this commit?

1. Fix documenttion
2. Begin documenting the options
3. change runtime options to build time options

Notes:


instantiate a configurator object, attach a command line interface to stdin?
hook that into the unit tests with ctest somehow?

use the "flags" module in the config file

or, have the ability to specify any number of config files, just superimpose/overwrite
based on the order of the files? Sure... 

Incremental steps:

0. Set up a command line parser interface.
1. Have GITR consume some input file via command line option.
2. Have GITR use "flags" instead of the build time options.
3. Each time an option is added/removed, a commit will be made.
4. The first commit will just be the boilerplate for the command loine parser etc.

Your mission:

Destroy them all, except for the ones in surface_model
Fix Atul's issue on fusiont6 as well.


ok, so there needs to be some separation of control...

a command line reader service is going to 

How can I properly split this into 3 parts?

Ok, so first have a pool interface and a libconfig specification - this leaves options to use
other frontends in the future. This is just to get the strings and numbers.

Then, you need a wanter and a provider and a go-getter that connects them via an interface.

wanter - I want configuration - I need a "use" object or an "impurity particle source" one,
say.

config_module_base is the machinery used to create a mapping to mapping objects.
You use "get" to actually get them. 

1. Instantiate an object. It has the command line parser and will open the file and attempt
   to consume the config file and create a "use" object.

2. Based on the "used" object, other objects will be created. How will they be made available?
   As a top level "config" object. 





























